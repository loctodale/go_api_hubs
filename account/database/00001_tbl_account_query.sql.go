// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: 00001_tbl_account_query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserBase = `-- name: AddUserBase :execresult
INSERT INTO tbl_account
(user_account, user_password, user_salt, user_role, user_created_at, user_updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
`

type AddUserBaseParams struct {
	UserAccount  string
	UserPassword string
	UserSalt     string
	UserRole     int32
}

func (q *Queries) AddUserBase(ctx context.Context, arg AddUserBaseParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, addUserBase,
		arg.UserAccount,
		arg.UserPassword,
		arg.UserSalt,
		arg.UserRole,
	)
}

const checkUserBaseExists = `-- name: CheckUserBaseExists :one
SELECT COUNT(*)
FROM tbl_account
WHERE user_account = $1
`

func (q *Queries) CheckUserBaseExists(ctx context.Context, userAccount string) (int64, error) {
	row := q.db.QueryRow(ctx, checkUserBaseExists, userAccount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAccounts = `-- name: GetAccounts :many
SELECT user_id, user_account, user_password, user_salt, user_role
FROM tbl_account
`

type GetAccountsRow struct {
	UserID       pgtype.UUID
	UserAccount  string
	UserPassword string
	UserSalt     string
	UserRole     int32
}

func (q *Queries) GetAccounts(ctx context.Context) ([]GetAccountsRow, error) {
	rows, err := q.db.Query(ctx, getAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountsRow
	for rows.Next() {
		var i GetAccountsRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserAccount,
			&i.UserPassword,
			&i.UserSalt,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneUserInfo = `-- name: GetOneUserInfo :one
SELECT user_id, user_account, user_password, user_salt, user_role
FROM tbl_account
WHERE user_account = $1
`

type GetOneUserInfoRow struct {
	UserID       pgtype.UUID
	UserAccount  string
	UserPassword string
	UserSalt     string
	UserRole     int32
}

func (q *Queries) GetOneUserInfo(ctx context.Context, userAccount string) (GetOneUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getOneUserInfo, userAccount)
	var i GetOneUserInfoRow
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserRole,
	)
	return i, err
}

const getOneUserInfoAdmin = `-- name: GetOneUserInfoAdmin :one
SELECT user_id, user_account, user_password, user_salt, user_login_time, user_logout_time, user_login_ip, user_created_at,user_updated_at, user_role
FROM tbl_account
WHERE user_account = $1
`

type GetOneUserInfoAdminRow struct {
	UserID         pgtype.UUID
	UserAccount    string
	UserPassword   string
	UserSalt       string
	UserLoginTime  pgtype.Timestamp
	UserLogoutTime pgtype.Timestamp
	UserLoginIp    pgtype.Text
	UserCreatedAt  pgtype.Timestamp
	UserUpdatedAt  pgtype.Timestamp
	UserRole       int32
}

func (q *Queries) GetOneUserInfoAdmin(ctx context.Context, userAccount string) (GetOneUserInfoAdminRow, error) {
	row := q.db.QueryRow(ctx, getOneUserInfoAdmin, userAccount)
	var i GetOneUserInfoAdminRow
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserLoginTime,
		&i.UserLogoutTime,
		&i.UserLoginIp,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.UserRole,
	)
	return i, err
}

const loginUserBase = `-- name: LoginUserBase :exec
UPDATE tbl_account
SET user_login_time = NOW(), user_logout_time = $1, user_login_ip = $2
WHERE user_account = $3 AND user_password = $4
`

type LoginUserBaseParams struct {
	UserLogoutTime pgtype.Timestamp
	UserLoginIp    pgtype.Text
	UserAccount    string
	UserPassword   string
}

func (q *Queries) LoginUserBase(ctx context.Context, arg LoginUserBaseParams) error {
	_, err := q.db.Exec(ctx, loginUserBase,
		arg.UserLogoutTime,
		arg.UserLoginIp,
		arg.UserAccount,
		arg.UserPassword,
	)
	return err
}

const logoutUserBase = `-- name: LogoutUserBase :exec
UPDATE tbl_account
SET user_logout_time = NOW()
WHERE user_account = $1
`

func (q *Queries) LogoutUserBase(ctx context.Context, userAccount string) error {
	_, err := q.db.Exec(ctx, logoutUserBase, userAccount)
	return err
}
